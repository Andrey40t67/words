<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>IMBA 3D Tracker — лицо • тело • руки</title>

  <!-- Three.js (UMD) -->
  <script src="https://unpkg.com/three@0.160.0/build/three.min.js" crossorigin="anonymous"></script>

  <!-- MediaPipe Tasks Vision (UMD bundle exposes global classes) -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision/vision_bundle.js" crossorigin="anonymous"></script>

  <style>
    :root{
      --bg1:#0b0f1a; --bg2:#101a2e; --glass:rgba(255,255,255,.06);
      --acc:#6cf0ff; --acc2:#9f80ff; --ok:#66ffb2; --warn:#ffda6c;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0; background: radial-gradient(1200px 800px at 80% -10%, #15294f 0%, transparent 70%),
                radial-gradient(1000px 800px at -10% 110%, #231845 0%, transparent 60%),
                linear-gradient(180deg, var(--bg1), var(--bg2));
      color:#e7f3ff; font-family: ui-sans-serif, system-ui, Segoe UI, Roboto, Helvetica, Arial, Apple Color Emoji, Segoe UI Emoji;
      overflow:hidden;
    }
    .wrap{position:fixed; inset:0; display:grid; grid-template-rows:auto 1fr; gap:10px; padding:14px}
    header{
      display:flex; gap:14px; align-items:center; justify-content:space-between;
      padding:10px 14px; border:1px solid rgba(255,255,255,.08); background:var(--glass);
      -webkit-backdrop-filter: blur(10px); backdrop-filter: blur(10px);
      border-radius:16px; box-shadow: 0 20px 60px rgba(0,0,0,.25), inset 0 1px 0 rgba(255,255,255,.07);
      animation: drop 600ms ease both;
    }
    @keyframes drop{from{transform:translateY(-10px); opacity:0} to{transform:none; opacity:1}}
    .brand{display:flex; gap:10px; align-items:center; letter-spacing:.3px}
    .brand .dot{
      width:10px;height:10px;border-radius:50%;
      background: conic-gradient(from 210deg at 50% 50%, var(--acc), var(--acc2), var(--ok), var(--acc));
      box-shadow: 0 0 20px 6px rgba(108,240,255,.35), 0 0 40px 10px rgba(159,128,255,.25);
      animation: pulse 2200ms ease-in-out infinite;
    }
    @keyframes pulse{0%,100%{transform:scale(1)} 50%{transform:scale(1.25)}}
    .brand h1{margin:0; font-size:18px; font-weight:700}
    .controls{display:flex; flex-wrap:wrap; gap:10px}
    .card{
      display:flex; align-items:center; gap:10px; padding:8px 12px; background:rgba(255,255,255,.05);
      border:1px solid rgba(255,255,255,.08); border-radius:14px;
    }
    .card label{font-size:13px; opacity:.9}
    .switch{display:inline-flex; align-items:center; gap:8px; font-size:13px}
    .switch input[type="checkbox"]{appearance:none; width:36px;height:20px;border-radius:999px; background:#3b455e; position:relative; outline:none; cursor:pointer; transition:.2s}
    .switch input[type="checkbox"]::after{
      content:""; position:absolute; top:2px; left:2px; width:16px;height:16px;border-radius:50%;
      background:white; transition:.2s; box-shadow:0 2px 6px rgba(0,0,0,.4)
    }
    .switch input[type="checkbox"]:checked{background:linear-gradient(90deg,var(--acc),var(--acc2))}
    .switch input[type="checkbox"]:checked::after{left:18px}
    select, button{
      font:inherit; color:#e7f3ff; background:#27314a; border:1px solid rgba(255,255,255,.12);
      border-radius:12px; padding:8px 10px; cursor:pointer;
    }
    button.primary{
      background:linear-gradient(90deg, #00d2ff, #7a5cff);
      border:none; font-weight:700; letter-spacing:.2px; box-shadow:0 10px 30px rgba(122,92,255,.35);
    }
    button.ghost{background:transparent;border:1px dashed rgba(255,255,255,.2)}
    #stage{position:absolute; inset:0; width:100%; height:100%}
    .foot{
      position:fixed; bottom:10px; left:50%; transform:translateX(-50%);
      padding:6px 10px; font-size:12px; opacity:.75; background:rgba(0,0,0,.25); border:1px solid rgba(255,255,255,.1); border-radius:12px
    }
    /* Hidden video feed (camera never shown) */
    video#cam{position:fixed; opacity:0; pointer-events:none; width:1px; height:1px; left:-9999px; top:-9999px}
    .badge{padding:6px 10px; border-radius:999px; font-size:12px; background:rgba(255,255,255,.08); border:1px solid rgba(255,255,255,.12)}
    .ok{color:#031; background: linear-gradient(90deg, rgba(102,255,178,.2), rgba(108,240,255,.18))}
    .warn{color:#2d1f00; background: linear-gradient(90deg, rgba(255,218,108,.25), rgba(255,170,83,.18))}
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <div class="brand">
        <div class="dot"></div>
        <h1>IMBA 3D Tracker</h1>
        <span id="status" class="badge warn">ожидание старта</span>
      </div>
      <div class="controls">
        <div class="card">
          <div class="switch"><input id="chkFace" type="checkbox" checked><label for="chkFace">Лицо</label></div>
          <div class="switch"><input id="chkBody" type="checkbox" checked><label for="chkBody">Тело</label></div>
          <div class="switch"><input id="chkHands" type="checkbox" checked><label for="chkHands">Руки</label></div>
        </div>

        <div class="card">
          <label for="selStyle">Стиль</label>
          <select id="selStyle">
            <option value="points" selected>Точки (неон)</option>
            <option value="pointsGlow">Точки + свечение</option>
          </select>
        </div>

        <div class="card">
          <label for="selQuality">Качество</label>
          <select id="selQuality" title="Pose: lite/full, остальные — универсальные">
            <option value="lite" selected>Lite (быстрее)</option>
            <option value="full">Full (точнее)</option>
          </select>
        </div>

        <div class="card">
          <button id="btnStart" class="primary">START</button>
          <button id="btnStop" class="ghost">STOP</button>
        </div>
      </div>
    </header>

    <main style="position:relative; min-height:0;">
      <canvas id="stage"></canvas>
      <video id="cam" playsinline muted autoplay></video>
    </main>
  </div>

  <div class="foot" id="foot">FPS: — • Face/Body/Hands: —/—/—</div>

<script>
(() => {
  // ======= Globals / State =======
  const video = document.getElementById('cam');
  const canvas = document.getElementById('stage');
  const statusBadge = document.getElementById('status');
  const foot = document.getElementById('foot');

  const ui = {
    start: document.getElementById('btnStart'),
    stop: document.getElementById('btnStop'),
    face: document.getElementById('chkFace'),
    body: document.getElementById('chkBody'),
    hands: document.getElementById('chkHands'),
    style: document.getElementById('selStyle'),
    quality: document.getElementById('selQuality')
  };

  // MediaPipe tasks
  let vision = null;
  let faceLm = null, poseLm = null, handLm = null;

  // Three.js scene
  let renderer, scene, camera, facePts, posePts, leftPts, rightPts;
  let lastT = performance.now(), frames = 0, fps = 0;

  // Geometry buffers (reused for smoothness & perf)
  let buf = {
    face: new Float32Array(468*3),
    pose: new Float32Array(33*3),
    left: new Float32Array(21*3),
    right: new Float32Array(21*3)
  };
  let smooth = {
    face: new Float32Array(buf.face.length),
    pose: new Float32Array(buf.pose.length),
    left: new Float32Array(buf.left.length),
    right: new Float32Array(buf.right.length)
  };

  // Utility mapping normalized landmark -> 3D coords
  function lmToXYZ(lm, out, off=0, lerp=0.35){
    // x,y in [0..1], z ~ [-? .. ?]; map to -1..1, flip Y
    const X = (lm.x*2 - 1);
    const Y = (1 - lm.y*2);
    const Z = -(lm.z || 0)*1.2; // keep shallow depth
    // Lerp towards new value to reduce jitter
    out[off+0] = out[off+0] + (X - out[off+0]) * lerp || X;
    out[off+1] = out[off+1] + (Y - out[off+1]) * lerp || Y;
    out[off+2] = out[off+2] + (Z - out[off+2]) * lerp || Z;
  }

  // Create THREE.Points with nice neon material
  function makePoints(capacity, baseSize=0.02, glow=false){
    const g = new THREE.BufferGeometry();
    g.setAttribute('position', new THREE.BufferAttribute(new Float32Array(capacity*3), 3));
    const m = new THREE.PointsMaterial({
      size: baseSize,
      transparent:true,
      opacity: glow ? 0.95 : 0.9,
      depthWrite:false
    });
    // Gradient via vertex colors
    const colors = new Float32Array(capacity*3);
    for (let i=0;i<capacity;i++){
      const t = i/capacity;
      const c = new THREE.Color().setHSL(0.55 + 0.25*t, 0.9, glow ? (0.6 + 0.3*(1-t)) : 0.55);
      colors[i*3+0]=c.r; colors[i*3+1]=c.g; colors[i*3+2]=c.b;
    }
    g.setAttribute('color', new THREE.BufferAttribute(colors,3));
    const mat = m;
    mat.vertexColors = true;
    const pts = new THREE.Points(g, mat);
    if (glow){
      pts.layers.enable(1);
      pts.material.blending = THREE.AdditiveBlending;
    }
    return pts;
  }

  function applyStyle(){
    const glow = ui.style.value === 'pointsGlow';
    const sFace = facePts?.material; const sPose = posePts?.material;
    const sL = leftPts?.material; const sR = rightPts?.material;
    [sFace,sPose,sL,sR].forEach(m=>{
      if(!m) return;
      m.blending = glow ? THREE.AdditiveBlending : THREE.NormalBlending;
      m.opacity = glow ? 0.95 : 0.9;
      m.needsUpdate = true;
    });
    renderer.toneMappingExposure = glow ? 1.35 : 1.0;
  }

  // ======= Init Three.js =======
  function initThree(){
    renderer = new THREE.WebGLRenderer({canvas, antialias:true, alpha:true});
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    renderer.setSize(innerWidth, innerHeight);
    renderer.outputColorSpace = THREE.SRGBColorSpace;

    scene = new THREE.Scene();

    camera = new THREE.PerspectiveCamera(55, innerWidth/innerHeight, 0.1, 50);
    camera.position.set(0, 0, 3.2);
    scene.add(camera);

    const amb = new THREE.AmbientLight(0x9fd1ff, 0.75);
    const dir = new THREE.DirectionalLight(0xffffff, 0.6); dir.position.set(1,2,3);
    scene.add(amb, dir);

    // Particles groups
    facePts = makePoints(468, 0.016, true);
    posePts = makePoints(33, 0.024, false);
    leftPts = makePoints(21, 0.022, true);
    rightPts = makePoints(21, 0.022, true);

    scene.add(facePts, posePts, leftPts, rightPts);

    applyStyle();

    window.addEventListener('resize', ()=>{
      camera.aspect = innerWidth/innerHeight; camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
    });
  }

  // ======= Init MediaPipe Tasks =======
  async function initTasks(){
    // wasm base path on jsDelivr (SIMD auto handled by FilesetResolver)
    vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision/wasm");

    // Face Landmarker (478 pts inc. some indices unused; API returns 468 landmarks)
    faceLm = await FaceLandmarker.createFromOptions(vision, {
      baseOptions: {
        modelAssetPath: "https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/latest/face_landmarker.task",
        delegate: "GPU"
      },
      runningMode: "VIDEO",
      numFaces: 1,
      outputFaceBlendshapes: false,
      outputFacialTransformationMatrixes: false,
      minTrackingConfidence: 0.6
    });

    // Pose Landmarker (quality from UI)
    await createPoseByQuality(ui.quality.value);

    // Hand Landmarker
    handLm = await HandLandmarker.createFromOptions(vision, {
      baseOptions: {
        modelAssetPath: "https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/latest/hand_landmarker.task",
        delegate: "GPU"
      },
      runningMode: "VIDEO",
      numHands: 2,
      minTrackingConfidence: 0.6
    });
  }

  async function createPoseByQuality(q){
    if (poseLm){ poseLm.close(); poseLm = null; }
    const modelURL = q === 'full'
      ? "https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_full/float16/latest/pose_landmarker_full.task"
      : "https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/latest/pose_landmarker_lite.task";
    poseLm = await PoseLandmarker.createFromOptions(vision, {
      baseOptions: { modelAssetPath: modelURL, delegate: "GPU" },
      runningMode: "VIDEO",
      outputSegmentationMasks: false,
      minTrackingConfidence: 0.6
    });
  }

  // ======= Camera =======
  async function startCamera(){
    // iOS/Safari safe constraints
    const stream = await navigator.mediaDevices.getUserMedia({
      video: {
        facingMode: "user",
        width: { ideal: 1280 },
        height: { ideal: 720 },
        frameRate: { ideal: 30, max: 60 }
      },
      audio: false
    });
    video.srcObject = stream;
    await video.play(); // must be after user gesture
  }

  // ======= Render / Detection Loop =======
  let running = false;

  async function loop(){
    if (!running) return;
    const now = performance.now();

    // FPS
    frames++;
    if (now - lastT >= 1000){ fps = frames; frames = 0; lastT = now; }

    const ts = now;

    // Run detectors (conditionally)
    let fRes=null, pRes=null, hRes=null;
    try{
      if (ui.face.checked && faceLm) fRes = faceLm.detectForVideo(video, ts);
      if (ui.body.checked && poseLm) pRes = poseLm.detectForVideo(video, ts);
      if (ui.hands.checked && handLm) hRes = handLm.detectForVideo(video, ts);
    }catch(e){
      console.warn('detect error', e);
    }

    // Update Three.js geometries
    if (fRes?.faceLandmarks?.length){
      const landmarks = fRes.faceLandmarks[0];
      for (let i=0;i<468;i++){
        const lm = landmarks[i];
        lmToXYZ(lm, smooth.face, i*3, 0.35);
        buf.face[i*3+0] = smooth.face[i*3+0];
        buf.face[i*3+1] = smooth.face[i*3+1];
        buf.face[i*3+2] = smooth.face[i*3+2];
      }
      facePts.visible = ui.face.checked;
      facePts.geometry.attributes.position.array.set(buf.face);
      facePts.geometry.attributes.position.needsUpdate = true;
    }else{
      facePts.visible = false;
    }

    if (pRes?.landmarks?.length){
      const lm = pRes.landmarks[0]; // first pose
      for (let i=0;i<Math.min(lm.length,33);i++){
        lmToXYZ(lm[i], smooth.pose, i*3, 0.38);
        buf.pose[i*3+0]=smooth.pose[i*3+0];
        buf.pose[i*3+1]=smooth.pose[i*3+1];
        buf.pose[i*3+2]=smooth.pose[i*3+2];
      }
      posePts.visible = ui.body.checked;
      posePts.geometry.attributes.position.array.set(buf.pose);
      posePts.geometry.attributes.position.needsUpdate = true;
    }else{
      posePts.visible = false;
    }

    // Hands (0..2); order may vary; map by handedness where possible
    if (hRes?.landmarks?.length){
      // Default hide
      leftPts.visible = rightPts.visible = false;

      for (let i=0;i<hRes.landmarks.length;i++){
        const lm = hRes.landmarks[i];
        const hand = hRes.handedness?.[i]?.[0]?.categoryName || (i===0?'Right':'Left'); // fallback
        const isRight = /right/i.test(hand);
        const targetSmooth = isRight ? smooth.right : smooth.left;
        const targetBuf = isRight ? buf.right : buf.left;
        const targetPts = isRight ? rightPts : leftPts;

        for (let k=0;k<lm.length; k++){
          lmToXYZ(lm[k], targetSmooth, k*3, 0.42);
          targetBuf[k*3+0]=targetSmooth[k*3+0];
          targetBuf[k*3+1]=targetSmooth[k*3+1];
          targetBuf[k*3+2]=targetSmooth[k*3+2];
        }
        targetPts.geometry.attributes.position.array.set(targetBuf);
        targetPts.geometry.attributes.position.needsUpdate = true;
        targetPts.visible = ui.hands.checked;
      }
    }else{
      leftPts.visible = rightPts.visible = false;
    }

    // Subtle camera drift for “hero” feel
    const t = ts*0.00025;
    camera.position.x = Math.sin(t)*0.12;
    camera.position.y = Math.cos(t*1.3)*0.06;
    camera.lookAt(0,0,0);

    renderer.render(scene, camera);

    // Footer info
    foot.textContent = `FPS: ${fps||'—'} • Face/Body/Hands: ${facePts.visible? '✓':'—'}/${posePts.visible? '✓':'—'}/${(leftPts.visible||rightPts.visible)? '✓':'—'}`;

    requestAnimationFrame(loop);
  }

  // ======= UI Handlers =======
  ui.start.addEventListener('click', async () => {
    try{
      ui.start.disabled = true;
      statusBadge.textContent = 'загрузка моделей…';
      statusBadge.className = 'badge warn';

      if (!renderer) initThree();
      await startCamera();
      if (!vision) await initTasks();

      applyStyle();

      running = true;
      statusBadge.textContent = 'работает';
      statusBadge.className = 'badge ok';
      loop();
    }catch(err){
      console.error(err);
      statusBadge.textContent = 'ошибка доступа к камере';
      statusBadge.className = 'badge warn';
      alert('Нужно HTTPS и системное разрешение камеры. Safari: страница должна быть в активной вкладке и запуск по клику.');
      ui.start.disabled = false;
    }
  });

  ui.stop.addEventListener('click', ()=>{
    running = false;
    statusBadge.textContent = 'остановлено';
    statusBadge.className = 'badge warn';
    if (video.srcObject){
      video.srcObject.getTracks().forEach(t=>t.stop());
      video.srcObject = null;
    }
    ui.start.disabled = false;
  });

  ui.style.addEventListener('change', applyStyle);

  ui.quality.addEventListener('change', async ()=>{
    if (!vision) return;
    statusBadge.textContent = 'переключение модели…';
    statusBadge.className = 'badge warn';
    await createPoseByQuality(ui.quality.value);
    statusBadge.textContent = running ? 'работает' : 'ожидание старта';
    statusBadge.className = running ? 'badge ok' : 'badge warn';
  });

  // Initial Three for pretty backdrop (before start)
  initThree();
})();
</script>
</body>
</html>
