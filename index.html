<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Hand Ghost 3D ‚Äî —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —Å–∞–π—Ç–æ–º —Ä—É–∫–∞–º–∏ + —Ä–∏—Å–æ–≤–∞–Ω–∏–µ</title>
  <style>
    :root {
      --bg: #0b0d12;
      --panel: rgba(255,255,255,.06);
      --accent: #8ad1ff;
      --good: #7CFC00;
      --warn: #ffb74d;
      --danger: #ff6b6b;
    }
    html, body { height: 100%; }
    body {
      margin: 0; background: var(--bg); color: #e6edf3; font: 14px/1.4 system-ui, -apple-system, Segoe UI, Roboto, Inter, Arial, sans-serif;
      overflow: hidden; touch-action: none;
    }
    #stage { position: absolute; inset: 0; overflow: hidden; }
    #gl { position: absolute; inset: 0; display: block; pointer-events: none; }
    #draw { position: absolute; inset: 0; display: block; pointer-events: none; }
    #cursor { position: absolute; width: 18px; height: 18px; border-radius: 999px; background: #fff; opacity: .85; transform: translate(-50%, -50%); pointer-events: none; mix-blend-mode: difference; box-shadow: 0 0 18px rgba(255,255,255,.6); }

    #ui {
      position: fixed; left: 12px; bottom: 12px; right: 12px; z-index: 10; display: grid; gap: 8px; grid-template-columns: repeat(12, 1fr);
    }
    .card {
      grid-column: 1 / -1; background: var(--panel); border: 1px solid rgba(255,255,255,.08); border-radius: 16px; padding: 12px; backdrop-filter: blur(8px);
    }
    .row { display: flex; flex-wrap: wrap; gap: 8px; align-items: center; }
    button, .seg { appearance: none; border: 1px solid rgba(255,255,255,.12); background: rgba(255,255,255,.08); color: #fff; padding: 10px 14px; border-radius: 12px; cursor: pointer; }
    button:disabled { opacity: .5; cursor: not-allowed; }
    label { display: inline-flex; align-items: center; gap: 8px; opacity: .9; }
    input[type="range"] { width: 160px; }

    .status { display: inline-flex; align-items: center; gap: 6px; padding: 8px 10px; border-radius: 999px; background: rgba(255,255,255,.08); border: 1px solid rgba(255,255,255,.12); }
    .dot { width: 10px; height: 10px; border-radius: 999px; background: #888; box-shadow: 0 0 10px currentColor; }
    .ok   { color: var(--good); }
    .warn { color: var(--warn); }
    .bad  { color: var(--danger); }

    .demo { position: fixed; top: 14px; right: 14px; z-index: 12; padding: 12px 16px; font-weight: 700; }
    .demo.hit { animation: pop .28s ease; }
    @keyframes pop { 0%{transform:scale(1)} 50%{transform:scale(1.08)} 100%{transform:scale(1)} }

    #hint { position: fixed; left: 50%; top: 50%; transform: translate(-50%, -50%); z-index: 9; text-align: center; opacity: .8; pointer-events: none; }
    #hint h1 { margin: 0 0 8px; font-size: 20px; font-weight: 700; letter-spacing: .2px; }
    #hint p { margin: 0; font-size: 13px; opacity: .9; }

    video#video { position: fixed; left: -9999px; top: -9999px; width: 1px; height: 1px; opacity: 0; }

    @media (min-width: 720px) {
      #ui { grid-template-columns: repeat(12, minmax(0,1fr)); }
      .card.controls { grid-column: 1 / span 8; }
      .card.status-bar { grid-column: 9 / -1; }
    }
  </style>
</head>
<body>
  <div id="stage">
    <canvas id="gl"></canvas>
    <canvas id="draw"></canvas>
    <div id="cursor" hidden></div>
  </div>

  <button id="demoBtn" class="demo hittable" title="–°–æ–∂–º–∏ –±–æ–ª—å—à–æ–π + —É–∫–∞–∑–∞—Ç–µ–ª—å–Ω—ã–π ‚Äî –∫–ª–∏–∫/drag">–ñ–º–∏ —Ä—É–∫–æ–π</button>

  <div id="ui">
    <div class="card controls">
      <div class="row">
        <button id="startBtn">‚ñ∂Ô∏è –í–∫–ª—é—á–∏—Ç—å –∫–∞–º–µ—Ä—É</button>
        <button id="stopBtn" disabled>‚èπ –í—ã–∫–ª—é—á–∏—Ç—å</button>
        <button id="clearBtn">üßπ –û—á–∏—Å—Ç–∏—Ç—å —Ä–∏—Å—É–Ω–æ–∫</button>
        <button id="toggleDrawBtn">‚úçÔ∏è –†–µ–∂–∏–º —Ä–∏—Å–æ–≤–∞–Ω–∏—è: –≤—ã–∫–ª</button>
        <label><input id="mirrorChk" type="checkbox" checked> –ó–µ—Ä–∫–∞–ª–∏—Ç—å</label>
        <label>–ü–æ—Ä–æ–≥ —â–∏–ø–∫–∞ <input id="pinchRange" type="range" min="0.010" max="0.090" step="0.005" value="0.035"></label>
        <label>–°—Ç–∞–±–∏–ª–∏–∑–∞—Ü–∏—è <input id="smoothRange" type="range" min="0" max="0.9" step="0.05" value="0.45"></label>
      </div>
      <div class="row" style="opacity:.8">
        <div>–ñ–µ—Å—Ç—ã: –ø—Ä–∞–≤–∞—è —Ä—É–∫–∞ ‚Äî –∫—É—Ä—Å–æ—Ä; <b>—â–∏–ø–æ–∫</b> –∫–æ—Ä–æ—Ç–∫–∏–π = –∫–ª–∏–∫, –¥–ª–∏–Ω–Ω—ã–π = drag; –ª–µ–≤–∞—è —Ä—É–∫–∞ <b>—â–∏–ø–æ–∫</b> –∏ –¥–≤–∏–∂–µ–Ω–∏–µ = —Å–∫—Ä–æ–ª–ª. –í–∫–ª—é—á–∏ ¬´–†–µ–∂–∏–º —Ä–∏—Å–æ–≤–∞–Ω–∏—è¬ª ‚Äî —â–∏–ø–∫–æ–º —Ä–∏—Å—É–µ—à—å.</div>
      </div>
    </div>
    <div class="card status-bar">
      <div class="row">
        <div class="status" id="permSt"><span class="dot"></span><span>–î–æ—Å—Ç—É–ø –∫ –∫–∞–º–µ—Ä–µ</span></div>
        <div class="status" id="modelSt"><span class="dot"></span><span>–ú–æ–¥–µ–ª—å</span></div>
        <div class="status" id="fpsSt"><span class="dot"></span><span id="fpsTxt">FPS ‚Äî ‚Ä¶</span></div>
      </div>
    </div>
  </div>

  <div id="hint">
    <h1>–î–∞–π –¥–æ—Å—Ç—É–ø –∫ –∫–∞–º–µ—Ä–µ –∏ –ø–æ–¥–Ω–µ—Å–∏ —Ä—É–∫–∏ –≤ –∫–∞–¥—Ä</h1>
    <p>–í–∏–¥–µ–æ –Ω–µ –ø–æ–∫–∞–∑—ã–≤–∞–µ—Ç—Å—è ‚Äî —Ç–æ–ª—å–∫–æ ¬´–ø—Ä–∏–∑—Ä–∞—á–Ω—ã–µ¬ª 3D-—Ä—É–∫–∏. –©–∏–ø–æ–∫ (–±–æ–ª—å—à–æ–π+—É–∫–∞–∑–∞—Ç–µ–ª—å–Ω—ã–π): –∫–ª–∏–∫/drag/—Ä–∏—Å–æ–≤–∞–Ω–∏–µ. –õ–µ–≤–æ–π —Ä—É–∫–æ–π ‚Äî —Å–∫—Ä–æ–ª–ª.</p>
  </div>

  <video id="video" playsinline muted></video>

  <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>

  <script>
  const $ = (sel) => document.querySelector(sel);
  const startBtn = $('#startBtn');
  const stopBtn = $('#stopBtn');
  const clearBtn = $('#clearBtn');
  const toggleDrawBtn = $('#toggleDrawBtn');
  const mirrorChk = $('#mirrorChk');
  const pinchRange = $('#pinchRange');
  const smoothRange = $('#smoothRange');
  const permSt = $('#permSt');
  const modelSt = $('#modelSt');
  const fpsSt = $('#fpsSt');
  const fpsTxt = $('#fpsTxt');
  const hint = $('#hint');
  const demoBtn = $('#demoBtn');

  const setDot = (el, cls) => { el.querySelector('.dot').className = 'dot ' + ({ok:'ok',warn:'warn',bad:'bad'}[cls]||''); };

  // ====== Camera ======
  const video = $('#video');
  let stream = null, running = false;
  async function startCamera(){
    try {
      setDot(permSt,'warn');
      stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode:'user', width:{ideal:1280}, height:{ideal:720}, frameRate:{ideal:30, max:60} }, audio:false });
      video.srcObject = stream; await video.play();
      setDot(permSt,'ok'); running=true; startBtn.disabled=true; stopBtn.disabled=false; hint.style.display='none';
      processLoop();
    } catch(e){ console.error(e); setDot(permSt,'bad'); alert('–ù—É–∂–µ–Ω HTTPS –∏ —Ä–∞–∑—Ä–µ—à–µ–Ω–∏–µ –∫–∞–º–µ—Ä—ã'); }
  }
  function stopCamera(){ running=false; if(stream){ stream.getTracks().forEach(t=>t.stop()); stream=null; } video.srcObject=null; startBtn.disabled=false; stopBtn.disabled=true; }
  startBtn.addEventListener('click', startCamera); stopBtn.addEventListener('click', stopCamera);

  // ====== Three.js scene ======
  const glCanvas = $('#gl');
  const renderer = new THREE.WebGLRenderer({ canvas: glCanvas, antialias:true, alpha:true, powerPreference:'high-performance' });
  const scene = new THREE.Scene();
  const camera = new THREE.OrthographicCamera();
  const hemi = new THREE.HemisphereLight(0xffffff, 0x223344, 1.0); scene.add(hemi);
  const dir = new THREE.DirectionalLight(0xffffff, 0.6); dir.position.set(0,0,1); scene.add(dir);

  function resize(){
    const w = glCanvas.clientWidth = window.innerWidth;
    const h = glCanvas.clientHeight = window.innerHeight;
    renderer.setSize(w,h,false);
    const dpr = Math.min(devicePixelRatio||1, 2); renderer.setPixelRatio(dpr);
    camera.left=-w/2; camera.right=w/2; camera.top=h/2; camera.bottom=-h/2; camera.near=-2000; camera.far=2000; camera.updateProjectionMatrix();
    setupDrawCanvas();
  }
  window.addEventListener('resize', resize);

  // ====== Ghost-hand mesh (cylinders + joints) ======
  const CONNECTIONS=[[0,1],[1,2],[2,3],[3,4],[0,5],[5,6],[6,7],[7,8],[0,9],[9,10],[10,11],[11,12],[0,13],[13,14],[14,15],[15,16],[0,17],[17,18],[18,19],[19,20]];
  function makeHandGroup(color){
    const g = new THREE.Group();
    const material = new THREE.MeshStandardMaterial({ color, transparent:true, opacity:0.35, metalness:0.2, roughness:0.4 });
    const jointMat = new THREE.MeshStandardMaterial({ color:0xffffff, transparent:true, opacity:0.5, metalness:0.0, roughness:0.6 });
    const cylinders=[], spheres=[];
    for(let i=0;i<CONNECTIONS.length;i++){
      const geom = new THREE.CylinderGeometry(6,6,1, 10, 1, true); // —Ä–∞–¥–∏—É—Å ~6px
      const m = new THREE.Mesh(geom, material);
      m.castShadow=false; m.receiveShadow=false; g.add(m); cylinders.push(m);
    }
    for(let i=0;i<21;i++){
      const s = new THREE.Mesh(new THREE.SphereGeometry(7, 12, 10), jointMat);
      g.add(s); spheres.push(s);
    }
    g.userData = { cylinders, spheres, material, jointMat, alpha: 0 };
    scene.add(g); return g;
  }
  const leftHand = makeHandGroup(0x8ad1ff);
  const rightHand = makeHandGroup(0xff9aa2);

  // ====== Drawing layer ======
  const drawCanvas = $('#draw'); const drawCtx = drawCanvas.getContext('2d');
  let drawMode=false; toggleDrawBtn.addEventListener('click', ()=>{ drawMode=!drawMode; toggleDrawBtn.textContent = `‚úçÔ∏è –†–µ–∂–∏–º —Ä–∏—Å–æ–≤–∞–Ω–∏—è: ${drawMode?'–≤–∫–ª':'–≤—ã–∫–ª'}`; });
  function setupDrawCanvas(){
    const w = drawCanvas.width = Math.floor(window.innerWidth * Math.min(devicePixelRatio||1,2));
    const h = drawCanvas.height = Math.floor(window.innerHeight * Math.min(devicePixelRatio||1,2));
    drawCanvas.style.width = window.innerWidth+'px'; drawCanvas.style.height = window.innerHeight+'px';
    drawCtx.lineCap='round'; drawCtx.lineJoin='round'; drawCtx.lineWidth = 6 * Math.max(1,(devicePixelRatio||1)*0.75); drawCtx.strokeStyle='#ffffff'; drawCtx.globalAlpha=0.95;
  }
  $('#clearBtn').addEventListener('click', ()=> drawCtx.clearRect(0,0,drawCanvas.width,drawCanvas.height));

  // ====== Cursor & gestures ======
  const cursorEl = $('#cursor');
  function updateCursor(x,y,vis=true){ if(!vis){cursorEl.hidden=true;return;} cursorEl.hidden=false; cursorEl.style.left=x+'px'; cursorEl.style.top=y+'px'; }
  function normToScreenPx(x,y){ const w=innerWidth,h=innerHeight; const mx = mirrorChk.checked ? (1-x) : x; return [mx*w, y*h]; }
  function distance(a,b){ const dx=a.x-b.x, dy=a.y-b.y, dz=(a.z||0)-(b.z||0); return Math.hypot(dx,dy,dz); }

  // Hysteresis for pinch
  const PINCH_ON = ()=> Number(pinchRange.value);     // closer than -> ON
  const PINCH_OFF = ()=> Number(pinchRange.value) + 0.012; // farther than -> OFF

  // Site control: right = cursor/click/drag, left = scroll
  let dragActive = false, dragStarted = false, dragElem=null;
  const ptrId = 9; // fixed pointer id
  function dispatchPointer(el, type, x, y){
    const e = new PointerEvent(type, { pointerId:ptrId, pointerType:'touch', clientX:x, clientY:y, bubbles:true, cancelable:true });
    el.dispatchEvent(e);
  }
  function startDrag(x,y){ const el = document.elementFromPoint(x,y) || document.body; dragElem = el; dispatchPointer(el,'pointerover',x,y); dispatchPointer(el,'pointerenter',x,y); dispatchPointer(el,'pointerdown',x,y); dragActive=true; }
  function moveDrag(x,y){ if(!dragElem) return; dispatchPointer(dragElem,'pointermove',x,y); }
  function endDrag(x,y){ if(!dragElem) return; dispatchPointer(dragElem,'pointerup',x,y); dispatchPointer(dragElem,'click',x,y); dragActive=false; dragElem=null; }

  // Scroll with left hand pinch
  let lastScrollY = null;

  // Drawing state
  let drawing=false, prevPt=null;

  // ====== Stabilization / visibility ======
  const MAX_HANDS = 2;
  const handState = [
    {visible:false, present:0, missing:0, smoothed:null, alpha:0, pinch:false, pinchTime:0, role:'left'},
    {visible:false, present:0, missing:0, smoothed:null, alpha:0, pinch:false, pinchTime:0, role:'right'}
  ];

  function fadeHand(group, targetAlpha){
    const ud = group.userData; ud.alpha += (targetAlpha - ud.alpha) * 0.25; // ease
    ud.material.opacity = 0.15 + 0.35*ud.alpha;
    ud.jointMat.opacity = 0.3 + 0.2*ud.alpha;
    group.visible = ud.alpha > 0.02;
  }

  // ====== Mediapipe Hands ======
  let hands = null, processing=false;
  async function initHands(){
    setDot(modelSt,'warn');
    hands = new Hands({ locateFile: (f)=>`https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}` });
    hands.setOptions({ maxNumHands:2, modelComplexity:1, minDetectionConfidence:0.7, minTrackingConfidence:0.7 });
    hands.onResults(onHands);
    setDot(modelSt,'ok');
  }

  async function processLoop(){
    if(!running) return;
    if(!hands) await initHands();
    if(!processing){ processing=true; try{ await hands.send({ image: video }); }catch(e){ console.error(e); } processing=false; }
    requestAnimationFrame(processLoop);
  }

  // Map mediapipe hands to left/right groups (by label or x)
  function resolveRoles(results){
    const out = [null, null];
    if(!results.multiHandLandmarks) return out;
    for(let i=0;i<results.multiHandLandmarks.length;i++){
      const lm = results.multiHandLandmarks[i];
      const label = results.multiHandedness?.[i]?.label || (lm[0].x < 0.5 ? 'Left':'Right');
      const idx = (label === 'Left') ? 0 : 1; // 0-left, 1-right
      out[idx] = lm;
    }
    return out;
  }

  // Update hand mesh from 21 landmarks
  function updateHandGroup(group, lm){
    const w=innerWidth, h=innerHeight, depthScale=600; const mirror = mirrorChk.checked;
    const ud = group.userData; const {cylinders, spheres} = ud;
    // positions array for reuse
    const P = new Array(21);
    for(let j=0;j<21;j++){
      const p = lm[j];
      const sx = (mirror ? (1-p.x) : p.x) * w - w/2;
      const sy = (0.5 - (p.y - 0.5)) * h;
      const sz = -p.z * depthScale;
      P[j] = new THREE.Vector3(sx, sy, sz);
      spheres[j].position.copy(P[j]);
      spheres[j].scale.setScalar(1.0);
    }
    // cylinders between connections
    for(let i=0;i<CONNECTIONS.length;i++){
      const [a,b]=CONNECTIONS[i]; const A=P[a], B=P[b]; const m=cylinders[i];
      const dir = new THREE.Vector3().subVectors(B,A); const len = Math.max(1, dir.length());
      const mid = new THREE.Vector3().addVectors(A,B).multiplyScalar(0.5);
      const q = new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0,1,0), dir.clone().normalize());
      m.position.copy(mid); m.quaternion.copy(q); m.scale.set(1, len, 1);
    }
  }

  // Smoothing
  function lerp(a,b,t){ return a+(b-a)*t; }
  function smoothPoint(prev, next, amt){ if(!prev) return {...next}; return { x: lerp(prev.x,next.x,amt), y: lerp(prev.y,next.y,amt), z: lerp(prev.z,next.z,amt) }; }

  // Main results handler
  let lastT = performance.now(), acc=0, frames=0;
  function onHands(results){
    const roles = resolveRoles(results);
    const groups = [leftHand, rightHand];

    for(let hIdx=0; hIdx<2; hIdx++){
      const lm = roles[hIdx];
      const S = handState[hIdx];
      if(lm){
        S.present++; S.missing=0; S.visible=true;
        // build smoothed
        if(!S.smoothed) S.smoothed = lm.map(p=>({x:p.x,y:p.y,z:p.z}));
        const alpha = 1 - Math.max(0.05, 1 - Number(smoothRange.value));
        for(let j=0;j<21;j++) S.smoothed[j] = smoothPoint(S.smoothed[j], lm[j], alpha);

        updateHandGroup(groups[hIdx], S.smoothed);
        fadeHand(groups[hIdx], 1);

        // gestures
        const tip = S.smoothed[8], thumb = S.smoothed[4];
        const [cx, cy] = normToScreenPx(tip.x, tip.y);
        const d = distance(tip, thumb);
        const was = S.pinch;
        if(!was && d < PINCH_ON()){ S.pinch = true; S.pinchTime = performance.now(); }
        if(was && d > PINCH_OFF()){ S.pinch = false; }

        // RIGHT HAND = pointer/drag/draw
        if(hIdx===1){
          updateCursor(cx,cy,true);
          if(drawMode){
            // draw with pinch hold
            const dpr = Math.min(devicePixelRatio||1,2); const dx = Math.round(cx*dpr), dy=Math.round(cy*dpr);
            if(S.pinch && !drawing){ drawing=true; prevPt={x:dx,y:dy}; }
            if(S.pinch && drawing && prevPt){ drawCtx.beginPath(); drawCtx.moveTo(prevPt.x,prevPt.y); drawCtx.lineTo(dx,dy); drawCtx.stroke(); prevPt={x:dx,y:dy}; }
            if(!S.pinch){ drawing=false; prevPt=null; }
          } else {
            // site control
            if(S.pinch && !dragStarted){ // check short vs long
              const t = performance.now() - S.pinchTime;
              if(t>180 && !dragActive){ startDrag(cx,cy); dragStarted=true; }
            }
            if(S.pinch && dragActive){ moveDrag(cx,cy); }
            if(!S.pinch){ if(dragActive){ endDrag(cx,cy); } else {
              // short click
              const t = performance.now() - S.pinchTime; if(t>30 && t<180){ const el = document.elementFromPoint(cx,cy) || document.body; el.click?.(); }
            } dragStarted=false; }
          }
        }

        // LEFT HAND = scroll when pinching
        if(hIdx===0){
          if(S.pinch){ if(lastScrollY==null) lastScrollY = cy; const dy = cy - lastScrollY; window.scrollBy({ top: dy*0.8, behavior:'auto' }); lastScrollY = cy; }
          else { lastScrollY = null; }
        }

      } else {
        // missing frame -> keep last few frames and fade
        S.missing++; if(S.missing>8) S.visible=false; fadeHand(groups[hIdx], S.visible? 0.6 : 0);
        if(hIdx===1) updateCursor(0,0,false);
        S.pinch=false; drawing=false; prevPt=null; if(hIdx===1 && dragActive){ endDrag(innerWidth/2, innerHeight/2); }
      }
    }

    renderer.render(scene, camera);

    // FPS
    const t = performance.now(); const dt=t-lastT; lastT=t; acc+=dt; frames++; if(acc>=500){ const fps=Math.round(1000*frames/acc); fpsTxt.textContent=`FPS ‚Äî ${fps}`; setDot(fpsSt, fps>=24?'ok':(fps>=14?'warn':'bad')); acc=0; frames=0; }
  }

  // ====== Boot ======
  function boot(){ resize(); renderer.setClearColor(0x000000,0); }
  boot();

  // ====== Video element (hidden) ======
  // draw nothing ‚Äî mediapipe —á–∏—Ç–∞–µ—Ç –∫–∞–¥—Ä—ã –ø—Ä—è–º–æ –∏–∑ <video>
  </script>
</body>
</html>
