<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>HandTrack 3D ‚Äî —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —Å–∞–π—Ç–æ–º —Ä—É–∫–∞–º–∏ + —Ä–∏—Å–æ–≤–∞–Ω–∏–µ</title>
  <style>
    :root {
      --bg: #0b0d12;
      --panel: rgba(255,255,255,.06);
      --accent: #8ad1ff;
      --good: #7CFC00;
      --warn: #ffb74d;
      --danger: #ff6b6b;
    }
    html, body { height: 100%; }
    body {
      margin: 0; background: var(--bg); color: #e6edf3; font: 14px/1.4 system-ui, -apple-system, Segoe UI, Roboto, Inter, Arial, sans-serif;
      overflow: hidden; touch-action: none; /* —á—Ç–æ–±—ã –Ω–µ —Å–∫—Ä–æ–ª–ª–∏–ª–æ –Ω–∞ –º–æ–±–∏–ª–∫–µ –ø—Ä–∏ –∂–µ—Å—Ç–∞—Ö */
    }
    #stage { position: absolute; inset: 0; overflow: hidden; }
    #gl { position: absolute; inset: 0; display: block; pointer-events: none; }
    #draw { position: absolute; inset: 0; display: block; pointer-events: none; }
    #cursor { position: absolute; width: 18px; height: 18px; border-radius: 999px; background: #fff; opacity: .85; transform: translate(-50%, -50%); pointer-events: none; mix-blend-mode: difference; box-shadow: 0 0 18px rgba(255,255,255,.6); }

    #ui {
      position: fixed; left: 12px; bottom: 12px; right: 12px; z-index: 10; display: grid; gap: 8px; grid-template-columns: repeat(12, 1fr);
    }
    .card {
      grid-column: 1 / -1; background: var(--panel); border: 1px solid rgba(255,255,255,.08); border-radius: 16px; padding: 12px; backdrop-filter: blur(8px);
    }
    .row { display: flex; flex-wrap: wrap; gap: 8px; align-items: center; }
    button, .seg { appearance: none; border: 1px solid rgba(255,255,255,.12); background: rgba(255,255,255,.08); color: #fff; padding: 10px 14px; border-radius: 12px; cursor: pointer; }
    button:disabled { opacity: .5; cursor: not-allowed; }
    label { display: inline-flex; align-items: center; gap: 8px; opacity: .9; }
    input[type="range"] { width: 160px; }

    .status { display: inline-flex; align-items: center; gap: 6px; padding: 8px 10px; border-radius: 999px; background: rgba(255,255,255,.08); border: 1px solid rgba(255,255,255,.12); }
    .dot { width: 10px; height: 10px; border-radius: 999px; background: #888; box-shadow: 0 0 10px currentColor; }
    .ok   { color: var(--good); }
    .warn { color: var(--warn); }
    .bad  { color: var(--danger); }

    .demo { position: fixed; top: 14px; right: 14px; z-index: 12; padding: 12px 16px; font-weight: 700; }
    .demo.hit { animation: pop .28s ease; }
    @keyframes pop { 0%{transform:scale(1)} 50%{transform:scale(1.08)} 100%{transform:scale(1)} }

    /* –ø–æ–¥—Å–∫–∞–∑–∫–∞ –ø–æ–≤–µ—Ä—Ö */
    #hint { position: fixed; left: 50%; top: 50%; transform: translate(-50%, -50%); z-index: 9; text-align: center; opacity: .8; pointer-events: none; }
    #hint h1 { margin: 0 0 8px; font-size: 20px; font-weight: 700; letter-spacing: .2px; }
    #hint p { margin: 0; font-size: 13px; opacity: .9; }

    /* —Å–∫—Ä—ã—Ç–æ–µ –≤–∏–¥–µ–æ –¥–ª—è –∑–∞—Ö–≤–∞—Ç–∞ –∫–∞–¥—Ä–æ–≤ */
    video#video { position: fixed; left: -9999px; top: -9999px; width: 1px; height: 1px; opacity: 0; }

    /* –∞–¥–∞–ø—Ç–∏–≤ */
    @media (min-width: 720px) {
      #ui { grid-template-columns: repeat(12, minmax(0,1fr)); }
      .card.controls { grid-column: 1 / span 8; }
      .card.status-bar { grid-column: 9 / -1; }
    }
  </style>
</head>
<body>
  <!-- –°—Ü–µ–Ω–∞: WebGL (3D —Ä—É–∫–∏), —Å–ª–æ–π —Ä–∏—Å–æ–≤–∞–Ω–∏—è –∏ –∫—É—Ä—Å–æ—Ä -->
  <div id="stage">
    <canvas id="gl"></canvas>
    <canvas id="draw"></canvas>
    <div id="cursor" hidden></div>
  </div>

  <!-- –ö–Ω–æ–ø–∫–∞-–¥–µ–º–æ (–∫–ª–∏–∫–Ω—É—Ç—å —â–∏–ø–∫–æ–º) -->
  <button id="demoBtn" class="demo hittable" title="–°–æ–∂–º–∏ –±–æ–ª—å—à–æ–π + —É–∫–∞–∑–∞—Ç–µ–ª—å–Ω—ã–π ‚Äî –±—É–¥–µ—Ç –∫–ª–∏–∫">–ñ–º–∏ —Ä—É–∫–æ–π</button>

  <!-- –ü–∞–Ω–µ–ª—å —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è -->
  <div id="ui">
    <div class="card controls">
      <div class="row">
        <button id="startBtn">‚ñ∂Ô∏è –í–∫–ª—é—á–∏—Ç—å –∫–∞–º–µ—Ä—É</button>
        <button id="stopBtn" disabled>‚èπ –í—ã–∫–ª—é—á–∏—Ç—å</button>
        <button id="clearBtn">üßπ –û—á–∏—Å—Ç–∏—Ç—å —Ä–∏—Å—É–Ω–æ–∫</button>
        <label><input id="mirrorChk" type="checkbox" checked> –ó–µ—Ä–∫–∞–ª–∏—Ç—å</label>
        <label>–ü–æ—Ä–æ–≥ —â–∏–ø–∫–∞ <input id="pinchRange" type="range" min="0.01" max="0.10" step="0.005" value="0.035"></label>
        <label>–°—Ç–∞–±–∏–ª–∏–∑–∞—Ü–∏—è <input id="smoothRange" type="range" min="0" max="0.8" step="0.05" value="0.35"></label>
      </div>
    </div>
    <div class="card status-bar">
      <div class="row">
        <div class="status" id="permSt"><span class="dot"></span><span>–î–æ—Å—Ç—É–ø –∫ –∫–∞–º–µ—Ä–µ</span></div>
        <div class="status" id="modelSt"><span class="dot"></span><span>–ú–æ–¥–µ–ª—å</span></div>
        <div class="status" id="fpsSt"><span class="dot"></span><span id="fpsTxt">FPS ‚Äî ‚Ä¶</span></div>
      </div>
    </div>
  </div>

  <!-- –ü–æ–¥—Å–∫–∞–∑–∫–∞ –ø–æ –∑–∞–ø—É—Å–∫—É (–∏—Å—á–µ–∑–Ω–µ—Ç –ø–æ—Å–ª–µ —Å—Ç–∞—Ä—Ç–∞) -->
  <div id="hint">
    <h1>–î–∞–π –¥–æ—Å—Ç—É–ø –∫ –∫–∞–º–µ—Ä–µ –∏ –ø–æ–¥–Ω–µ—Å–∏ —Ä—É–∫–∏ –≤ –∫–∞–¥—Ä</h1>
    <p>–í–∏–¥–µ–æ –Ω–µ –ø–æ–∫–∞–∑—ã–≤–∞–µ—Ç—Å—è ‚Äî —Ç–æ–ª—å–∫–æ 3D-—Å–∫–µ–ª–µ—Ç —Ä—É–∫. –°–æ–∂–º–∏ –±–æ–ª—å—à–æ–π –ø–∞–ª–µ—Ü –∏ —É–∫–∞–∑–∞—Ç–µ–ª—å–Ω—ã–π, —á—Ç–æ–±—ã —Ä–∏—Å–æ–≤–∞—Ç—å –∏–ª–∏ ¬´–∫–ª–∏–∫–∞—Ç—å¬ª.</p>
  </div>

  <!-- –°–∫—Ä—ã—Ç–æ–µ –≤–∏–¥–µ–æ –¥–ª—è –∫–∞–¥—Ä–æ–≤ -->
  <video id="video" playsinline muted></video>

  <!-- –ë–∏–±–ª–∏–æ—Ç–µ–∫–∏ -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

  <script>
  // ======= –£–¢–ò–õ–ò–¢–´ UI =======
  const $ = (sel) => document.querySelector(sel);
  const startBtn = $('#startBtn');
  const stopBtn = $('#stopBtn');
  const clearBtn = $('#clearBtn');
  const mirrorChk = $('#mirrorChk');
  const pinchRange = $('#pinchRange');
  const smoothRange = $('#smoothRange');
  const permSt = $('#permSt');
  const modelSt = $('#modelSt');
  const fpsSt = $('#fpsSt');
  const fpsTxt = $('#fpsTxt');
  const hint = $('#hint');
  const demoBtn = $('#demoBtn');

  const setDot = (el, cls) => {
    el.querySelector('.dot').className = 'dot ' + ({ok:'ok',warn:'warn',bad:'bad'}[cls]||'');
  };

  // ======= –í–ò–î–ï–û =======
  const video = $('#video');
  let stream = null;
  let running = false;

  async function startCamera() {
    try {
      setDot(permSt, 'warn');
      stream = await navigator.mediaDevices.getUserMedia({
        video: {
          facingMode: 'user',
          width: { ideal: 1280 },
          height: { ideal: 720 },
          frameRate: { ideal: 30, max: 60 }
        },
        audio: false
      });
      video.srcObject = stream;
      await video.play();
      setDot(permSt, 'ok');
      running = true;
      startBtn.disabled = true;
      stopBtn.disabled = false;
      hint.style.display = 'none';
      processLoop();
    } catch (e) {
      console.error(e);
      setDot(permSt, 'bad');
      alert('–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –¥–æ—Å—Ç—É–ø –∫ –∫–∞–º–µ—Ä–µ. –ù—É–∂–µ–Ω HTTPS –∏ —è–≤–Ω–æ–µ —Ä–∞–∑—Ä–µ—à–µ–Ω–∏–µ.');
    }
  }

  async function stopCamera() {
    running = false;
    if (stream) { stream.getTracks().forEach(t => t.stop()); stream = null; }
    video.srcObject = null;
    startBtn.disabled = false;
    stopBtn.disabled = true;
  }

  startBtn.addEventListener('click', startCamera);
  stopBtn.addEventListener('click', stopCamera);

  // ======= –°–¶–ï–ù–ê THREE.JS (3D —Å–∫–µ–ª–µ—Ç —Ä—É–∫) =======
  const glCanvas = $('#gl');
  const renderer = new THREE.WebGLRenderer({ canvas: glCanvas, antialias: true, alpha: true, powerPreference: 'high-performance' });
  const scene = new THREE.Scene();
  const camera = new THREE.OrthographicCamera();

  const handGroups = [new THREE.Group(), new THREE.Group()];
  handGroups.forEach(g => scene.add(g));

  const lineMatL = new THREE.LineBasicMaterial({ color: 0x8ad1ff, transparent: true, opacity: 0.75 });
  const lineMatR = new THREE.LineBasicMaterial({ color: 0xff9aa2, transparent: true, opacity: 0.75 });
  const ptsMatL  = new THREE.PointsMaterial({ color: 0xffffff, size: 8, sizeAttenuation: false, transparent: true, opacity: 0.9 });
  const ptsMatR  = new THREE.PointsMaterial({ color: 0xffffff, size: 8, sizeAttenuation: false, transparent: true, opacity: 0.9 });

  const CONNECTIONS = [
    [0,1],[1,2],[2,3],[3,4],      // –±–æ–ª—å—à–æ–π
    [0,5],[5,6],[6,7],[7,8],      // —É–∫–∞–∑–∞—Ç–µ–ª—å–Ω—ã–π
    [0,9],[9,10],[10,11],[11,12], // —Å—Ä–µ–¥–Ω–∏–π
    [0,13],[13,14],[14,15],[15,16], // –±–µ–∑—ã–º—è–Ω–Ω—ã–π
    [0,17],[17,18],[18,19],[19,20]  // –º–∏–∑–∏–Ω–µ—Ü
  ];

  function createHandGeometry() {
    const lineGeom = new THREE.BufferGeometry();
    lineGeom.setAttribute('position', new THREE.BufferAttribute(new Float32Array(CONNECTIONS.length*2*3), 3));
    const ptsGeom = new THREE.BufferGeometry();
    ptsGeom.setAttribute('position', new THREE.BufferAttribute(new Float32Array(21*3), 3));
    return { lineGeom, ptsGeom };
  }

  const handMeshes = handGroups.map((g, idx) => {
    const { lineGeom, ptsGeom } = createHandGeometry();
    const line = new THREE.LineSegments(lineGeom, idx===0?lineMatL:lineMatR);
    const pts  = new THREE.Points(ptsGeom, idx===0?ptsMatL:ptsMatR);
    g.add(line); g.add(pts);
    return { lineGeom, ptsGeom, line, pts };
  });

  function resize() {
    const w = glCanvas.clientWidth = window.innerWidth;
    const h = glCanvas.clientHeight = window.innerHeight;
    renderer.setSize(w, h, false);
    const dpr = Math.min(window.devicePixelRatio || 1, 2);
    renderer.setPixelRatio(dpr);

    // –û—Ä—Ç–æ-–∫–∞–º–µ—Ä–∞: –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –≤ –ø–∏–∫—Å–µ–ª—è—Ö —Å—Ü–µ–Ω—ã
    camera.left = -w/2; camera.right = w/2; camera.top = h/2; camera.bottom = -h/2; camera.near = -1000; camera.far = 1000; camera.updateProjectionMatrix();

    // —Ö–æ–ª—Å—Ç —Ä–∏—Å–æ–≤–∞–Ω–∏—è
    setupDrawCanvas();
  }
  window.addEventListener('resize', resize);

  // ======= –°–õ–û–ô –†–ò–°–û–í–ê–ù–ò–Ø (2D) =======
  const drawCanvas = $('#draw');
  const drawCtx = drawCanvas.getContext('2d');
  let drawing = false;
  let prevPt = null;
  function setupDrawCanvas(){
    const w = drawCanvas.width = Math.floor(window.innerWidth * Math.min(devicePixelRatio||1,2));
    const h = drawCanvas.height = Math.floor(window.innerHeight * Math.min(devicePixelRatio||1,2));
    drawCanvas.style.width = window.innerWidth + 'px';
    drawCanvas.style.height = window.innerHeight + 'px';
    drawCtx.lineCap = 'round';
    drawCtx.lineJoin = 'round';
    drawCtx.lineWidth = 6 * Math.max(1, (devicePixelRatio||1)*0.75);
    drawCtx.strokeStyle = '#ffffff';
    drawCtx.globalAlpha = 0.95;
  }
  clearBtn.addEventListener('click', () => { drawCtx.clearRect(0,0,drawCanvas.width, drawCanvas.height); });

  // ======= –õ–û–ì–ò–ö–ê –ñ–ï–°–¢–û–í =======
  let lastPinch = false;
  let pinchDownAt = 0;
  const cursorEl = $('#cursor');

  function normToScreenPx(x, y) {
    const w = window.innerWidth, h = window.innerHeight;
    const mx = mirrorChk.checked ? (1 - x) : x;
    return [mx * w, y * h];
  }

  function updateCursor(x, y, visible=true) {
    if (!visible) { cursorEl.hidden = true; return; }
    cursorEl.hidden = false;
    cursorEl.style.left = x + 'px';
    cursorEl.style.top  = y + 'px';
  }

  function distance(a, b) {
    const dx = a.x-b.x, dy=a.y-b.y, dz=(a.z||0)-(b.z||0); return Math.hypot(dx,dy,dz);
  }

  function maybeClickAt(x,y) {
    const el = document.elementFromPoint(x, y);
    if (!el) return;
    // –∫–ª–∏–∫–∞–µ–º —Ç–æ–ª—å–∫–æ –ø–æ —è–≤–Ω—ã–º —Ü–µ–ª—è–º (–±–µ–∑–æ–ø–∞—Å–Ω–µ–µ)
    const target = el.closest('.hittable');
    if (target) {
      target.classList.add('hit');
      setTimeout(()=>target.classList.remove('hit'), 280);
      target.click();
    }
  }

  demoBtn.addEventListener('click', () => {
    demoBtn.textContent = '‚úÖ –ü–æ–ø–∞–ª!';
    setTimeout(()=>demoBtn.textContent = '–ñ–º–∏ —Ä—É–∫–æ–π', 1200);
  });

  // –°–≥–ª–∞–∂–∏–≤–∞–Ω–∏–µ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç (—ç–∫—Å–ø–æ–Ω. —Ñ–∏–ª—å—Ç—Ä)
  function smooth(prev, next, amt) {
    if (!prev) return next;
    return { x: prev.x + (next.x - prev.x) * amt, y: prev.y + (next.y - prev.y) * amt, z: prev.z + (next.z - prev.z) * amt };
  }

  // ======= MEDIAPIPE HANDS =======
  let hands = null;
  let processing = false;

  async function initHands() {
    setDot(modelSt, 'warn');
    hands = new Hands({ locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}` });
    hands.setOptions({
      maxNumHands: 2,
      modelComplexity: 1,              // 0 –±—ã—Å—Ç—Ä–µ–µ, 1 —Ç–æ—á–Ω–µ–µ
      minDetectionConfidence: 0.6,
      minTrackingConfidence: 0.6
    });
    hands.onResults(onHands);
    setDot(modelSt, 'ok');
  }

  async function processLoop() {
    if (!running) return;
    if (!hands) await initHands();
    if (!processing) {
      processing = true;
      try { await hands.send({ image: video }); } catch (e) { console.error(e); }
      processing = false;
    }
    requestAnimationFrame(processLoop);
  }

  // ======= –†–ï–ù–î–ï–† –ö–ê–î–†–ê –†–£–ö =======
  let smoothed = [null, null];
  const depthScale = 600; // –≥–ª—É–±–∏–Ω–∞ 3D (–ø–æ–¥–±–µ—Ä–∏—Ç–µ –ø—Ä–∏ –∂–µ–ª–∞–Ω–∏–∏)

  function onHands(results) {
    const w = window.innerWidth, h = window.innerHeight;

    // –æ—á–∏—Å—Ç–∏—Ç—å –≥–µ–æ–º–µ—Ç—Ä–∏—é (–ø–æ —É–º–æ–ª—á–∞–Ω–∏—é ‚Äî –ø—Ä—è—á–µ–º)
    handGroups.forEach((g, i) => { g.visible = false; });

    if (results.multiHandLandmarks && results.multiHandLandmarks.length) {
      for (let i = 0; i < Math.min(2, results.multiHandLandmarks.length); i++) {
        const lm = results.multiHandLandmarks[i];
        const handed = results.multiHandedness?.[i]?.label || (i===0?'Left':'Right');
        const idx = i; // 0/1

        // –°–≥–ª–∞–∂–∏–≤–∞–µ–º –∫–∞–∂–¥—ã–π –º–∞—Ä–∫–µ—Ä
        const alpha = Number(smoothRange.value);
        smoothed[idx] = smoothed[idx] || lm.map(p=>({x:p.x,y:p.y,z:p.z}));
        for (let j = 0; j < 21; j++) smoothed[idx][j] = smooth(smoothed[idx][j], lm[j], 1 - Math.max(0.05, 1 - alpha));

        // –û–±–Ω–æ–≤–∏—Ç—å 3D –≥–µ–æ–º–µ—Ç—Ä–∏—é
        const { lineGeom, ptsGeom } = handMeshes[idx];
        const lp = lineGeom.attributes.position.array;
        const pp = ptsGeom.attributes.position.array;
        const mirror = mirrorChk.checked;
        for (let j = 0; j < 21; j++) {
          const p = smoothed[idx][j];
          const sx = (mirror ? (1 - p.x) : p.x) * w - w/2;
          const sy = (0.5 - (p.y - 0.5)) * h; // –ø–µ—Ä–µ–≤–æ—Ä–æ—Ç Y –≤ –æ—Ä—Ç–æ-–∫–∞–º–µ—Ä–µ
          const sz = -p.z * depthScale;
          pp[j*3+0] = sx; pp[j*3+1] = sy; pp[j*3+2] = sz;
        }
        let k = 0;
        for (const [a,b] of CONNECTIONS) {
          lp[k++] = pp[a*3+0]; lp[k++] = pp[a*3+1]; lp[k++] = pp[a*3+2];
          lp[k++] = pp[b*3+0]; lp[k++] = pp[b*3+1]; lp[k++] = pp[b*3+2];
        }
        lineGeom.attributes.position.needsUpdate = true;
        ptsGeom.attributes.position.needsUpdate = true;
        handGroups[idx].visible = true;

        // –ö—É—Ä—Å–æ—Ä –∏ —Ä–∏—Å–æ–≤–∞–Ω–∏–µ ‚Äî –±–µ—Ä—ë–º –∫–æ–Ω—á–∏–∫ —É–∫–∞–∑–∞—Ç–µ–ª—å–Ω–æ–≥–æ (8) –∏ –±–æ–ª—å—à–æ–π (4)
        const tip = smoothed[idx][8];
        const thumb = smoothed[idx][4];
        const [cx, cy] = normToScreenPx(tip.x, tip.y);
        updateCursor(cx, cy, true);

        const d = distance(tip, thumb);
        const pinch = d < Number(pinchRange.value);

        // –†–∏—Å–æ–≤–∞–Ω–∏–µ: —É–¥–µ—Ä–∂–∏–≤–∞–π —â–∏–ø–æ–∫
        const dpr = Math.min(devicePixelRatio||1, 2);
        const dx = Math.round(cx * dpr), dy = Math.round(cy * dpr);
        if (pinch && !lastPinch) {
          drawing = true; prevPt = {x:dx, y:dy}; pinchDownAt = performance.now();
          // ¬´–∫–ª–∏–∫¬ª –ø–æ —ç–ª–µ–º–µ–Ω—Ç—É, –µ—Å–ª–∏ —â–∏–ø–æ–∫ –∫–æ—Ä–æ—Ç–∫–∏–π (<180–º—Å)
          maybeClickAt(cx, cy);
        }
        if (pinch && drawing && prevPt) {
          drawCtx.beginPath();
          drawCtx.moveTo(prevPt.x, prevPt.y);
          drawCtx.lineTo(dx, dy);
          drawCtx.stroke();
          prevPt = {x:dx, y:dy};
        }
        if (!pinch) { drawing = false; prevPt = null; }
        lastPinch = pinch;
      }
    } else {
      updateCursor(0,0,false);
      lastPinch = false; drawing = false; prevPt = null;
    }

    // –†–µ–Ω–¥–µ—Ä 3D —Å—Ü–µ–Ω—ã
    renderer.render(scene, camera);

    // FPS
    fpsMeter();
  }

  // ======= FPS =======
  let lastT = performance.now();
  let acc = 0, frames = 0;
  function fpsMeter(){
    const t = performance.now();
    const dt = t - lastT; lastT = t; acc += dt; frames++;
    if (acc >= 500) { // –æ–±–Ω–æ–≤–ª—è–µ–º 2 —Ä–∞–∑–∞ –≤ —Å–µ–∫—É–Ω–¥—É
      const fps = Math.round(1000 * frames / acc);
      fpsTxt.textContent = `FPS ‚Äî ${fps}`;
      setDot(fpsSt, fps >= 24 ? 'ok' : (fps >= 14 ? 'warn' : 'bad'));
      acc = 0; frames = 0;
    }
  }

  // ======= –ó–ê–ü–£–°–ö =======
  function boot(){
    resize();
    renderer.setClearColor(0x000000, 0); // –ø—Ä–æ–∑—Ä–∞—á–Ω–æ—Å—Ç—å
  }
  boot();

  </script>
</body>
</html>
